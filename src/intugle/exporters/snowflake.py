import re
from .base import Exporter
from intugle.libs.smart_query_generator.models.models import CategoryType
from intugle.core import settings

RESERVED_WORDS = {'start', 'end', 'select', 'from', 'where', 'order', 'group', 'join', 'table', 'on'}

def clean_name(name: str) -> str:
    """Cleans an identifier to be a safe logical name for the Snowflake Semantic Model."""
    cleaned = name.strip().strip('"')
    # Replace invalid characters with underscore
    cleaned = re.sub(r'[^a-zA-Z0-9_$]', '_', cleaned)
    # Ensure it doesn't start with a number
    if re.match(r'^[0-9]', cleaned):
        cleaned = f'_{cleaned}'
    # Check against a list of common reserved words and prefix if necessary
    if cleaned.lower() in RESERVED_WORDS:
        return f'_{cleaned}'
    return cleaned

def quote_identifier(name: str) -> str:
    """Ensure the identifier is wrapped in exactly one pair of double quotes."""
    clean_name = name.strip().strip('"')
    return f'"{clean_name}"'

class SnowflakeExporter(Exporter):
    def export(self, **kwargs) -> dict:
        """
        Converts the internal manifest to a Snowflake Semantic Model YAML structure.
        """
        manifest = self.manifest
        
        # Get database and schema from profiles.yml
        profile = settings.PROFILES.get("etl", {}).get("outputs", {}).get("dev", {})
        database = profile.get("database")
        schema = profile.get("schema")

        tables_list = []
        relationships_list = []

        # Process sources into tables
        for source in manifest.sources.values():
            table_dict = {
                "name": clean_name(source.table.name),
                "description": source.table.description,
                "base_table": {
                    "database": database,
                    "schema": schema,
                    "table": source.table.name
                },
                "dimensions": [],
                "facts": []
            }

            # Map columns to dimensions and facts
            for column in source.table.columns:
                if column.category == CategoryType.dimension:
                    dimension = {
                        "name": clean_name(column.name),
                        "description": column.description,
                        "expr": quote_identifier(column.name),
                        "data_type": column.type,
                        "unique": column.name == source.table.key
                    }
                    table_dict["dimensions"].append(dimension)
                elif column.category == CategoryType.measure:
                    fact = {
                        "name": clean_name(column.name),
                        "description": column.description,
                        "expr": quote_identifier(column.name),
                        "data_type": column.type
                    }
                    table_dict["facts"].append(fact)
            
            tables_list.append(table_dict)

        # Process relationships
        for rel in manifest.relationships.values():
            relationship = {
                "name": rel.name,
                "left_table": clean_name(rel.source.table),
                "right_table": clean_name(rel.target.table),
                "relationship_columns": [
                    {
                        "left_column": clean_name(rel.source.column),
                        "right_column": clean_name(rel.target.column)
                    }
                ],
                "join_type": "left_outer",  # Defaulting join type
                "relationship_type": rel.type
            }
            relationships_list.append(relationship)

        # Construct the final semantic_model dictionary
        semantic_model_output = {
            "name": "intugle_generated_model",
            "description": "Semantic model generated by Intugle",
            "tables": tables_list,
            "relationships": relationships_list
        }
        
        return semantic_model_output
